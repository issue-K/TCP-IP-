```TCP```协议, 一旦两台主机建立连接, 每个主机就会拥有单独的输入流和输出流

通过```close```关闭套接字, 会同时关闭这两个流, 这样做是不妥当的.

因为我们想在发送完自己的数据后关掉输出流, 但是仍需要接收对方没发完的消息.



#### 半关闭函数

```c
int shutdown(int sock,int howto)
```

 ```sock```: 需要断开的套接字文件描述符

```howto```: 传递断开方式信息, 取值有如下三种

- SHUT_RD: 断开输入流
- SHUT_WR: 断开输出流
- SHUT_RDWR: 同时断开I/O流

注意, 当断开输入流时, 会立刻清空输入缓冲区的数据。

当断开输出流时, 却会把输出缓冲区的数据发完。 



### 为什么需要半关闭

比如现在让服务端完成一个需求, 接收来自客户端的连接, 并向其发送一个文件的数据, 最后再接收客户端发来的数据包.

现在客户端在接收服务端发来的数据时, 只能不停的调用```read```函数而不知道什么时候数据才算发完.(获取可以约定一个文件传输的末尾终止符, 但这样要求文件本身数据不包括这个终止符, 似乎也不是很妥当. 解决这个问题其实很容易, 但我们在稍后的章节再来讨论, 暂且当成一个无法处理的问题)

除非当服务端关闭流(执行```close,shutdown```之类的函数)

但是服务端执行```close```会把输入流也关掉, 这样无法去接收稍后客户端返回的数据, 所以此时应该采用半关闭的方式.

具体代码见```client.c,server.c```

